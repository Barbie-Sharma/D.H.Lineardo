# D.H. Lineardo

Kinematics deals with the spatial locations and velocities of a robot's end effectors and its internal joints. There are two parts to it, namely: forward and inverse kinematics. After studying composite rotations, homogeneous coordinates, doing a lot of matrix multiplication of paper, and (finally!) understanding the D.H. notation, I bring to you, D.H. LineardoðŸŽ¨ . It's a simulation of a 2D RR robot in MATLAB. When I ran the script for the first time, I noticed that my random theta equations were making an infinity symbol. So I plotted the locus of the points, and âœ¨voilÃ âœ¨. Playing around with different equations to vary the symbolic variable 'theta' resulted into different shapes. That's where my sketchy (pun intended) arm got its name from. 

 
BUT that was hit-or-miss logic to draw shapes. So, I sent it to school. Now, it uses inverse kinematics to converge to the desired position.ðŸ’¡ Inverse kinematics finds the values for the joint variables 'q' that satisfy the arm equation, given a desired position 'p' and orientation 'R' for the tool. I used the numerical solution of Newton-Raphson iteration algorithm to implement the inverse kinematics relation for my configuration. In real-time scenarios, numerical methods are faster than the closed-form solution from a computation perspective. An important concept used in the algorithm is the Jacobian matrix. It is the matrix that maps the relationship between the tool configuration velocity and joint space velocity. 
